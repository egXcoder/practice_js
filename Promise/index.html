<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <button onclick="runTest()">Click Me To Test</button>
    <p id="output">Output</p>
    <script>

        function runTest(){
            const promise1 = new Promise((resolve, reject) => {
                for (let i = 0; i < 100; i++) {
                    console.log("promise initialize task is called"); //called first
                }
                resolve(1);
            });

            promise1.then((value)=>{
                let calcValue = 0;
                for(let i=value;i<1000000000;i++){
                    console.log("calculating"); //called third on main thread after main thread gets empty,its on main thread because ui is hanged
                    calcValue+=i;
                }
                return calcValue;
            });

            for (let i = 0; i < 100; i++) {
                console.log("hello world"); //called second
            }
        }

        function chainingHandlersOnPromise(){
            //it typically implement the chain of responsibility design pattern
            //where each callback has responsibility for doing an action and he has the power to pass the output
            //to the next callback or reject and this will stop the promise execution immediately
            const promise1 = new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('foo');
                }, 300);
            });

            promise1
                .then(value => { return value + ' and bar'; }) //is going to run after foo is resolved and resolve to "foo and bar"
                .then(value => { return value + ' and bar again'; }) //is going to run after "foo and bar" is resolved and resolve new value
                .then(value => { return value + ' and again'; })
                .then(value => { return value + ' and again'; })
                .then(value => { console.log(value) })
                .catch(err => { console.log(err) });
        }

        function differenceBetweenLazyEvaluationAndPromise(){
            let sum = () => 1+1; //Lazy Evaluation,we will defer the evaluation of sum later on the code
            console.log(sum); //sum is just a function, not executed
            console.log(sum()); //we are ready to calculate sum now and this will give us = 2


            //this is NOT lazy evalutation, the task inside promise is going to run right now 
            new Promise((resolve,reject)=>{
                resolve(1+1);
            })
        }

        function checkWhatWillHappenToMainThreadIfPromiseIsRejected() {
            //creating a new promise, sum is going to be fullfilled before we get the line of console.log
            const myPromise = new Promise((resolve, reject) => {
                console.log(resolve); //this is a function
                console.log(reject); //this is a function
                
                //it means promise has failed with his task,and it is going to throw exception on the promise context
                //this exception won't affect the main thread operations
                reject('error has occured during calculation'); 
                resolve(sum);//it means promise has successeded with his task and return sum
            });

            console.log("hello world"); //still printing hello world even when promise throws exception
        }

        function checkWhatWillHappenToMainThreadIfPromiseIsRejected() {
            //creating a new promise, sum is going to be fullfilled before we get the line of console.log
            const myPromise = new Promise((resolve, reject) => {
                console.log(resolve); //this is a function
                console.log(reject); //this is a function
                
                //it means promise has failed with his task,and it is going to throw exception on the promise context
                //this exception won't affect the main thread operations
                reject('error has occured during calculation'); 
                resolve(sum);//it means promise has successeded with his task and return sum
            });

            console.log("hello world"); //still printing hello world even when promise throws exception
        }

        function checkIfYouCanReachPromiseInternalStateFromMainThread(){
            //creating a new promise, sum is going to be fullfilled before we get the line of console.log
            const myPromise = new Promise((resolve, reject) => {
                let sum = 0;
                for (let i = 0; i < 10; i++) {
                    sum += i;
                }
                resolve(sum);
            });

            console.log(myPromise); //by logging it you can see its fullfilled and value = 45
            //there is no way to get the promise internal state from here,
            //not status and not the value, there is NOTHING like myPromise.value or myPromise.status
            //the best you can do is logging
        }

        function checkIfPromiseExecuteItsInstructionOnSameThread(){
            //creating a new promise, is going to run the nested task on same thread right now
            const myPromise = new Promise((resolve, reject) => {
                let sum = 0;
                for(let i=0;i<10000000000000;i++){
                    sum+=i;
                }
                resolve(sum);
            });
            //everything hangs
        }


    </script>
</body>
</html>