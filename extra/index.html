<html>

<head>
    <!-- 
        Scripts with defer never block the page.
        Scripts with defer always execute when the DOM is ready (but before DOMContentLoaded event). 
        Deferred scripts keep their relative order, So even though small.js loads first, it still waits and runs after long.js executes.

        <script defer src="https://javascript.info/article/script-async-defer/long.js"></script>
        <script defer src="https://javascript.info/article/script-async-defer/small.js"></script>
    -->

    <!-- 
        The async attribute is somewhat like defer
        The async attribute means that a script is completely independent:
        Scripts with async never block the page.
        DOMContentLoaded and async scripts don’t wait for each other.
        small script will run first before long because small.js will download first

        <script async src="https://javascript.info/article/script-async-defer/long.js"></script>
        <script async src="https://javascript.info/article/script-async-defer/small.js"></script>
    -->
</head>

<body>
    <script>
        //this function is assigned into the window object and it will be global function
        //so later you can call it via window.globalFunction() and it will work
        function globalFunction() {
            //“this” keyword refers to the object that the function is a property of.
            console.log(this);
        }

        //obj object will be hoisted with property of name and a function of getName()
        function localFunction() {
            var obj = {
                name: "vivek",
                getName: function () {
                    //“this” keyword refers to the object that the function is a property of, which is obj
                    console.log(this.name);
                }
            }

            obj.getName();
        }

        //call and apply and bind are used to alter the context of calling a method to a different context
        //so the below code, someObject.myMethod is called with the arguments but "this" context
        // is altered from using someObject, it will use someOtherObject instead
        //call and apply, do invoke the method
        //bind is just returning a new function with the altered context
        function differenceBetweenCallAndApplyAndBind() {
            var someObject = {
                myProperty: 'Foo',
                myMethod: function (prefix, postfix) {
                    alert(prefix + this.myProperty + postfix);
                }
            };

            var someOtherObject = {
                myProperty: 'Bar'
            };

            someObject.myMethod('<', '>'); // alerts '<Foo>'
            someObject.myMethod.call(someOtherObject, '<', '>'); // alerts '<Bar>'
            someObject.myMethod.apply(someOtherObject, ['<', '>']); // alerts '<Bar>'

            let newFunc = someObject.myMethod.bind(someOtherObject, '<', '>');
            newFunc(); // alerts '<Bar>'
        }

        function showHelpfulBrowserObjects() {
            console.log(window.navigator); //helpful to get meta data about the browser and operation system
            console.log(window.screen); //helpful to get meta data about width and heights of the screen
        }

        function encodeAndDecodeURI() {
            var uri = "my test.asp?name=ståle&car=saab";
            console.log(encodeURI(uri)); //my%20test.asp?name=st%C3%A5le&car=saab
            console.log(decodeURI(uri)); //my test.asp?name=ståle&car=saab
        }

        //Currying is an advanced technique to transform a function of arguments n, to n functions of one or less arguments.
        //For Example, if we have a function f(a,b) , then the function after currying, will be transformed to f(a)(b).
        //By using the currying technique, we do not change the functionality of a function, we just change the way it is invoked.
        //The main benefit of currying is when you need to use the same call with some of the same parameters a lot.
        function showCurryingFunctionality() {
            let multiply = (a, b) => a * b;
            let add = (a,b) => a + b;
            let minus = (a,b)=> a - b;
            let divide = (a,b)=> a / b;

            function currying(a) {
                return (b) => {
                    return (fn) => {
                        return fn(a, b);
                    }
                }
            }

            //since i am going to do operations on same parameters many times so instead of calling same parameter 
            //over and over again which is not good for dry concept we use this technique to avoid the following lines 
            // multiply(4,3);
            // add(4,3);
            // minus(4,3);
            // divide(4,3); 

            let parametersToOperateOn = currying(4)(3);
            parametersToOperateOn(multiply); //12
            parametersToOperateOn(add); //7
            parametersToOperateOn(minus); //1
            parametersToOperateOn(divide); //1.33


        }

        // globalFunction();
        // localFunction();
        // differenceBetweenCallAndApplyAndBind();
        // showHelpfulBrowserObjects(); 
        // encodeAndDecodeURI();
        // showCurryingFunctionality();
    </script>
</body>


</html>