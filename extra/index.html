<html>

<head>
    <!-- 
        Scripts with defer never block the page.
        Scripts with defer always execute when the DOM is ready (but before DOMContentLoaded event). 
        Deferred scripts keep their relative order, So even though small.js loads first, it still waits and runs after long.js executes.

        <script defer src="https://javascript.info/article/script-async-defer/long.js"></script>
        <script defer src="https://javascript.info/article/script-async-defer/small.js"></script>
    -->

    <!-- 
        The async attribute is somewhat like defer
        The async attribute means that a script is completely independent:
        Scripts with async never block the page.
        DOMContentLoaded and async scripts don’t wait for each other.
        small script will run first before long because small.js will download first

        <script async src="https://javascript.info/article/script-async-defer/long.js"></script>
        <script async src="https://javascript.info/article/script-async-defer/small.js"></script>
    -->
</head>

<body>
    <script>
        //this function is assigned into the window object and it will be global function
        //so later you can call it via window.globalFunction() and it will work
        function globalFunction() {
            //“this” keyword refers to the object that the function is a property of.
            console.log(this);
        }

        //obj object will be hoisted with property of name and a function of getName()
        function localFunction() {
            var obj = {
                name: "vivek",
                getName: function () {
                    //“this” keyword refers to the object that the function is a property of, which is obj
                    console.log(this.name);
                }
            }

            obj.getName();
        }

        //call and apply and bind are used to alter the context of calling a method to a different context
        //so the below code, someObject.myMethod is called with the arguments but "this" context
        // is altered from using someObject, it will use someOtherObject instead
        //call and apply, do invoke the method
        //bind is just returning a new function with the altered context
        function differenceBetweenCallAndApplyAndBind() {
            var someObject = {
                myProperty: 'Foo',
                myMethod: function (prefix, postfix) {
                    alert(prefix + this.myProperty + postfix);
                }
            };

            var someOtherObject = {
                myProperty: 'Bar'
            };
            
            someObject.myMethod('<', '>'); // alerts '<Foo>'
            someObject.myMethod.call(someOtherObject, '<', '>'); // alerts '<Bar>'
            someObject.myMethod.apply(someOtherObject, ['<', '>']); // alerts '<Bar>'

            let newFunc = someObject.myMethod.bind(someOtherObject, '<', '>');
            newFunc(); // alerts '<Bar>'
        }

        function showHelpfulBrowserObjects() {
            console.log(window.navigator); //helpful to get meta data about the browser and operation system
            console.log(window.screen); //helpful to get meta data about width and heights of the screen
        }

        function encodeAndDecodeURI() {
            var uri = "my test.asp?name=ståle&car=saab";
            console.log(encodeURI(uri)); //my%20test.asp?name=st%C3%A5le&car=saab
            console.log(decodeURI(uri)); //my test.asp?name=ståle&car=saab
        }

        globalFunction();
        localFunction();
        // differenceBetweenCallAndApplyAndBind();
        // showHelpfulBrowserObjects(); 
        // encodeAndDecodeURI();
    </script>
</body>


</html>